---
title: "Figure 3 related DGE Analyses for CD62L^-^ Treg comparing Colon vs. non-Colon Residency"
subtitle: "Supplementary Figure 3 related subfigures for CD62L^-^ negative, physiologically tissue-resident Treg: DGE Scatter Plot, Hallmark GSEA Barcode Plots, Zscore Heatmap with downstream Metascape Analysis. Also, RPKM bar plots for selected genes and all resident Treg (CD62L^+^ & CD62L^-^) are created"
author: "David Dittmar"
date: "`r Sys.Date()`"
bibliography: Rscripts.bib
nocite: |
  '@Zhou2019', '@MIRAGAIA2019493'
output:
  html_document:
    df_print: paged
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_float: yes
    code_folding: hide
---

***

```{r, include=FALSE}
# Load required libraries
library(edgeR)
library(AnnotationDbi)
library(org.Mm.eg.db) #for mouse
library(tibble)
#library(plyr)
library(dplyr)
library(gplots)
library(readxl)
library(ggplot2)
library(cowplot)
library(ggrepel)
library(tidyr)
library(scales)
library(pryr)
library(ecoflux)
```

```{r setup, include=FALSE}
# Set global chunk options
knitr::opts_chunk$set(echo = TRUE, include = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
# ...packages.bib file is also written here
knitr::write_bib(.packages(), "Figure3_TregDGEScatter_GSEA_Heatmap_Metascape_cvnc.b.Cd62Lneg_packages.bib")
```

```{r}
# Load required counts, metadata and annotaion RDS files
counts.m<-readRDS("./RCTDIR/counts.m.rds")
metad.m<-readRDS("./METADIR/metad.m.rds")
stid<-readRDS("./METADIR/stid.rds")
```
* First, required data objects (counts, metadata, short transcript ID) and R packages are loaded. 
* This is the starting point for most analyses conducted on bulk RNA-seq data for the associated manuscript.

***

# Data Preparation
* For the analysis, the data and metadata have to be prepared and properly annotated.

## Annotation Data Frame
* An annotation data frame with 4 columns is constructed.
* The additional EntrezID column is required for possible downstream pathway analyses or annotation operations.
```{r}
genes.df<-as.data.frame(strsplit2(stid,"[$]"))
colnames(genes.df)<-c("EnsemblID","GeneSymbol","Length","GeneType")
genes.df$EnsemblID<-as.character(genes.df$EnsemblID)
genes.df$GeneSymbol<-as.character(genes.df$GeneSymbol)
genes.df$Length<-as.numeric(as.character(genes.df$Length))
genes.df$GeneType<-as.character(genes.df$GeneType)
genes.df$EntrezID<- mapIds(org.Mm.eg.db,
                    keys=genes.df$GeneSymbol,
                    column="ENTREZID",
                    keytype="SYMBOL",
                    multiVals="first")
rownames(genes.df)<-stid
head(genes.df, n=5L)
#See if the gene length values are still as they should, so this should yield an empty vector
which(strsplit2(stid,"[$]")[,3] %in% genes.df$Length==FALSE)
```

## Subsetting Index
* In this analysis, we focus on CD62L^-^ tissue-resident Treg from colon, spleen and liver.
* A subsetting index is generated accordingly.
```{r}
bclsn.ind<-grepl("wt",metad.m$appl)&grepl("neg", metad.m$treat)&(grepl("S", metad.m$org)|grepl("C", metad.m$org)|grepl("L", metad.m$org))
print(paste(sum(bclsn.ind),"samples enter the analysis!"))
```

## Counts
* Here, the comprehensive counts data frame is reduced using the subsetting index.
```{r}
#Subsetting the respective counts object (counts.m)
counts.bclsn<-counts.m[,bclsn.ind]
paste(ncol(counts.bclsn),"samples are selected:")
colnames(counts.bclsn)
```

## Metadata
* The metadata has to be reduced accordingly. 
* The original order of samples is introduced for downstream re-ordering of the read count table.
* An additional group variable assigning colon-re-isolated samples to one group and spleen- or liver-resident Treg to the other is introduced, as well.
* This enables the comparison of lymphoid vs. non-lymphoid tissue-resident Treg (CD62L^-^) in the steady-stat, underlying this analysis.
* Additionally, a group variable for coloring to distinguish spleen and liver is introduced.

```{r}
# subsetting and ordering
metad.bclsn<-metad.m[bclsn.ind,] %>% mutate(orig.ord = 1:sum(bclsn.ind)) %>%
  arrange(grp) %>% arrange(org)
# additional group variables
metad.bclsn<-mutate(metad.bclsn, 
                    cvnc = case_when(org == "C" ~ "colon", 
                                        org %in% c("L","S") ~ "spleen/liver"),
                    cls = case_when(org == "C" ~ "colon",
                                          org == "L" ~ "liver",
                                          org == "S" ~ "spleen"))
# index for re-ordering counts
counts.bclsn.ind<-metad.bclsn$orig.ord
head(metad.bclsn, n = 8)
#the group variables for downstream DEG comparisons
cvnc.bclsn<-factor(as.character(metad.bclsn$cvnc))
cvnc.bclsn
organ.bclsn<-factor(as.character(metad.bclsn$cls))
organ.bclsn
```

## Re-ordering Counts Data Frame Columns
* Here, read counts are re-ordered according to the metadata object.
```{r}
counts.bclsn.ord<-counts.bclsn[,counts.bclsn.ind]
head(counts.bclsn.ord, n=4L)
counts.bclsn<-counts.bclsn.ord
rm(counts.bclsn.ord)
```

## Consistency Check
* In order to avoid wrongful labelling, sample_IDs are used to confirm that the counts and metadata objects are consistent.
```{r}
if (sum(colnames(counts.bclsn)==metad.bclsn$sample_ID)==sum(bclsn.ind)) {
  print("Counts and metadata are properly subsetted and in accordance with each other. The analysis can be proceeded with!")
}else {
  print("Something is inconsistent, check the code above for errors during subsetting!")
}
```

## DGE List Objects
* A DGEList object is generated, the main class of the edgeR package. 
* For full functionality, the counts.bclsn, organ.bclsn and genes.df variables are used to do so.
```{r}
dgel.bclsn<-DGEList(counts = counts.bclsn, group = organ.bclsn, genes = genes.df)
head(dgel.bclsn$samples, n=13L)
head(dgel.bclsn$genes, n=4L)
```

## Exclusion of Rare Transcripts
* The "filterByExpr()" function is used to determine which genes have sufficiently large counts to be retained in a statistical analysis. 
* Only genes fulfilling that criterion are kept and also normalization factors are calculated.
```{r}
keep.bclsn <- filterByExpr(dgel.bclsn)
dgel.bclsn <- dgel.bclsn[keep.bclsn, , keep.lib.sizes=FALSE]
dgel.bclsn <- calcNormFactors(dgel.bclsn)
print(paste(table(keep.bclsn)[1],"genes are discarded while",table(keep.bclsn)[2], "genes are retained in the analysis!"))
```

## Log~2~(cpm) & Zscore Calculation
* In this step, Log~2~(cpm), scaled data (Zscores) are calculated.
* A batch-correction for the prep-batch is also performed.
```{r}
# log2-transformed cpms with a prior count of 2
bclsn.log.cpm <- cpm(dgel.bclsn, prior.count = 2, log = TRUE) 
# Zscore transformation of raw log.cpms
bclsn.log.cpm.scaled.transposed<-(scale(t(bclsn.log.cpm)))
bclsn.log.cpm.scaled<-data.matrix(t(bclsn.log.cpm.scaled.transposed))
rm(bclsn.log.cpm.scaled.transposed)
# design with the organ identity to be preserved
bclsn.design.plots <- model.matrix(~0+organ.bclsn)
# prep-batch correction
bclsn.log.cpm.cor <- removeBatchEffect(bclsn.log.cpm, batch = metad.bclsn$pb,
                                       design = bclsn.design.plots)
# Zscore transformation of batch-corrected log.cpms
bclsn.log.cpm.scaled.transposed<-(scale(t(bclsn.log.cpm.cor)))
bclsn.log.cpm.scaled.cor<-data.matrix(t(bclsn.log.cpm.scaled.transposed))
rm(bclsn.log.cpm.scaled.transposed, bclsn.design.plots)
```

***

# Differential Gene Expression (DGE) analysis

## Designs for DGE
* Data exploration revealed that PCR cycles are most suitable for batch correction if we compare colon with liver/spleen.
* Additionally we can correct for prep-batch.
* Hence, the variables should be included as blocking factors.
```{r}
# blocking factors
pcr2<-factor(metad.bclsn$PCR2.Cy)
pb<-factor(metad.bclsn$pb)
# design with contrast of interest: colon vs. non-colon
bclsn.cvnc.design.dge<-model.matrix(~0+cvnc.bclsn+pb+pcr2)
colnames(bclsn.cvnc.design.dge)[1:2]<- c("colon","liver_spleen")
as_tibble(bclsn.cvnc.design.dge)
```

* For individual pairwise DGE comparisons, an alternative design is required.
* Batch-correction for prep-batch can be carried out as in logCPM computation above and is consequently introduced as blocking factor.

```{r}
# blocking factor
pb
# design with all three organs separate
bclsn.organ.design.dge <- model.matrix(~0+organ.bclsn+pb)
colnames(bclsn.organ.design.dge)[1:3] <- c("colon", "liver", "spleen")
as_tibble(bclsn.organ.design.dge)
```
## Dispersion Estimation
* Hereafter, dispersion is estimated and the biological coefficient of variation is plotted.
```{r}
#colon vs non-colon
dgel.bclsn<-estimateDisp(dgel.bclsn,design=bclsn.cvnc.design.dge,robust=TRUE)
dgel.bclsn$common.dispersion # 0.1111957
```

* Alternative design:

```{r}
dgel.bclsn.organ<-dgel.bclsn
dgel.bclsn.organ<-estimateDisp(dgel.bclsn.organ, design=bclsn.organ.design.dge,robust=TRUE)
dgel.bclsn.organ$common.dispersion # 0.1111957
```

## GLM Fitting
* Fitting genewise glms (generalized linear model) for the constructed designs.
```{r}
bclsn.cvnc.fit<-glmQLFit(y = dgel.bclsn, design = bclsn.cvnc.design.dge)
bclsn.organ.fit<-glmQLFit(y = dgel.bclsn.organ, design = bclsn.organ.design.dge)
```

## DGE for Contrasts of Interest (COI)

### Colon vs. non-Colon
* The interest in this analysis lies in the differences between Treg re-isolated from colon versus liver & spleen. 
* Thus, our contrast of interest is "colon - liver_spleen" for the DGE analysis. 
* We can have a quick look at how many genes are DE with a FC > 1.5 and FDR < 0.05.
```{r}
# Contrast of Interest
bclsn.cvnc.con<-makeContrasts(colon - liver_spleen, levels=bclsn.cvnc.design.dge)
# DGE testing against fc = 1.5.
bclsn.cvnc.tr <- glmTreat(bclsn.cvnc.fit, contrast=bclsn.cvnc.con, lfc=log2(1.5))
bclsn.cvnc.tr.qstat<-topTags(bclsn.cvnc.tr,n = Inf)
bclsn.cvnc.tr.qdt<-decideTestsDGE(bclsn.cvnc.tr)
summary(bclsn.cvnc.tr.qdt)
```

#### Exporting DGE Statistics
* The data frame contained in the glmTreat function results is stored for direct access.
```{r}
write.table(x = bclsn.cvnc.tr.qstat$table,
            file = "./ANALDIR/SupplementaryFigure3e_TregDGE_cvnc_bas.neg_FC1.5.txt",
            quote=FALSE, 
            sep = "\t",
            col.names = TRUE,
            row.names = FALSE)
```

### Colon vs. Liver & Colon vs. Spleen & Liver vs. Spleen
* Alternative Design: We do all comparisons to combine differential gene lists.
```{r}
# Contrasts of Interest
## Colon vs. Liver
bclsn.cvl.con<-makeContrasts(colon - liver, levels=bclsn.organ.design.dge) 
## Colon vs. Spleen
bclsn.cvs.con<-makeContrasts(colon - spleen, levels=bclsn.organ.design.dge) 
## Liver vs. Spleen
bclsn.lvs.con<-makeContrasts(liver - spleen, levels=bclsn.organ.design.dge) 
#colon vs liver
bclsn.cvl.tr <- glmTreat(bclsn.organ.fit, contrast=bclsn.cvl.con, lfc=log2(1.5))
bclsn.cvl.tr.qstat<-topTags(bclsn.cvl.tr,n = Inf)
bclsn.cvl.tr.qdt<-decideTestsDGE(bclsn.cvl.tr)
summary(bclsn.cvl.tr.qdt)
#colon vs spleen
bclsn.cvs.tr <- glmTreat(bclsn.organ.fit, contrast=bclsn.cvs.con, lfc=log2(1.5))
bclsn.cvs.tr.qstat<-topTags(bclsn.cvs.tr,n = Inf)
bclsn.cvs.tr.qdt<-decideTestsDGE(bclsn.cvs.tr)
summary(bclsn.cvs.tr.qdt)
#liver vs spleen
bclsn.lvs.tr <- glmTreat(bclsn.organ.fit, contrast=bclsn.lvs.con, lfc=log2(1.5))
bclsn.lvs.tr.qstat<-topTags(bclsn.lvs.tr,n = Inf)
bclsn.lvs.tr.qdt<-decideTestsDGE(bclsn.lvs.tr)
summary(bclsn.lvs.tr.qdt)
```

***

# DEG Visualization as Scatterplot
* Hereafter, DEGs are visualized *via* a scatter plot.
* The colon vs. non-colon resident CD62L^-^ Treg comparison will be the basis for this.
* At the same time the comparison can be understood as non-lymphoid tissue (NLT) vs. lymphoid tissue (LT), in line with the nomenclature of the Miragaia et al. 2019 paper.

## Data Preparation
* In order not to exclude GOI, the data is no further filtered than already facilitated above when accounting for rare transcripts.
* Necessary data transformations for the scatter plot are carried out as well: columns with individual logCPMs (calculated from logCPM and logFC).
```{r}
# Extraction of data frame from glmTreat result
bclsn.cvnc.tr.qstat.scat <- bclsn.cvnc.tr.qstat$table %>% #is a data frame
  # Introduction of logRPKM column
  mutate(logRPKM=logCPM-log2(Length * 0.001),
         # Transformation for scatter plot --> individual log CPMs
         logCPMnonColon = logCPM - logFC/2, # non-colon
         logCPMcolon = logCPM + logFC/2) # colon
nrow(bclsn.cvnc.tr.qstat.scat)
# Separation of significantly up and down regulated genes
bclsn.cvnc.tr.qstat.scat.UP<-filter(bclsn.cvnc.tr.qstat.scat, logFC >= 0 & FDR < 0.05)
bclsn.cvnc.tr.qstat.scat.DN<-filter(bclsn.cvnc.tr.qstat.scat, logFC <= 0 & FDR < 0.05)
nrow(bclsn.cvnc.tr.qstat.scat.UP)
nrow(bclsn.cvnc.tr.qstat.scat.DN)

```

## Exporting UP and DN regulated Genes
* Significantly up and down regulated genes are exported in the following.
```{r}
#extract filtered gene lists
write.table(rownames(bclsn.cvnc.tr.qstat.scat.UP),
            file = "./ANALDIR/SupplementaryFigure3e_TregDGE_cvnc_bas.neg.sig.UP.txt",
            col.names = "GeneID",
            quote=FALSE, 
            row.names = FALSE)
write.table(rownames(bclsn.cvnc.tr.qstat.scat.DN),
            file = "./ANALDIR/SupplementaryFigure3e_TregDGE_cvnc_bas.neg.sig.DN.txt",
            col.names = "GeneID",
            quote=FALSE, 
            row.names = FALSE)
```

## Scatter Plot

### Definition of Genes of Interest (GOI)
* Hereafter, GOI are taken from Miragaia et al. 2019 (Figure 2 B) presenting Treg subpopulations of the steady-state.
* The question addressed here is whether our data is in line with their findings. 
* [Here you can have a look at the figure](https://pubmed.ncbi.nlm.nih.gov/30737144/#&gid=article-figures&pid=figure-2-uid-2)

```{r}
# non-lymphoid tissue
tm_fig2_panel_NLT<-rev(c("Ccr1","Ccr2","Gzmb","Il10","Il1rl1","Kdm6b","Gata3","Areg","S100a4","Itgae","Rora","Klrg1","Lgals1","Fgl2","Cmtm7","Cd44","Icos","Ctla4","Pim1","Ikzf2","Pdcd1","Cd83","Relb","Tnfrsf9","Tnfrsf4"))
# lymphoid tissue
tm_fig2_panel_LT<-rev(c("Stat1","Ccr7","S1pr1","Sell","Bcl2","Tcf7"))
```

### Color-coded geom_text_repel data frames
* First, we prepare some labels to be able to label data points for all categories with a single call to geom_text_repel.

```{r}
bclsn.cvnc.qstat.scat.ann <- bclsn.cvnc.tr.qstat.scat %>%
  mutate(
    ann.col = case_when(
      GeneSymbol %in% tm_fig2_panel_NLT ~ "brown4",
      GeneSymbol %in% tm_fig2_panel_LT ~ "navy"),
    goi.cat = case_when(
      logFC <= 0 & FDR < 0.05 ~ paste0("down in colon (",as.character(nrow(bclsn.cvnc.tr.qstat.scat.DN)),")"),
      logFC >= 0 & FDR < 0.05 ~ paste0("up in colon (",as.character(nrow(bclsn.cvnc.tr.qstat.scat.UP)),")"),
      TRUE ~ "non DE")
  )
head(bclsn.cvnc.qstat.scat.ann)
bclsn.cvnc.qstat.scat.ann.label <- filter(bclsn.cvnc.qstat.scat.ann, !is.na(ann.col))
```

### Scatter plot with GOI highlighted (Supplementary Figure 3 e)
* Hereafter, the scatter plot is generated and plotted.
```{r, fig.height=2.6}
bclsn.scat.cvnc.nlt.lt <- ggplot(bclsn.cvnc.tr.qstat.scat) + 
  aes(x=logCPMnonColon, y=logCPMcolon) +
  scale_x_continuous(limits = c(-5,17),
                     breaks = c(-3,0,3,6,9,12,15),
                     expand = c(0,0)
                     )+
  scale_y_continuous(limits = c(-5,17),
                     breaks = c(-3,0,3,6,9,12,15),
                     expand = c(0,0)
                     )+
  geom_point(colour=rgb(50,50,50,30,maxColorValue = 255), shape=16, size = .375) +
  geom_point(data=filter(bclsn.cvnc.qstat.scat.ann, goi.cat != "non DE"),
             aes(x=logCPMnonColon, y=logCPMcolon, color=goi.cat), 
             shape=16, 
             size = .5, 
             alpha=.75) +
  scale_color_manual(name = "Significantly DEGs",
                     values = c("lightslateblue","peru"),
                     guide = guide_legend(override.aes = list(size = 3)))+
  geom_text_repel(data = bclsn.cvnc.qstat.scat.ann.label,
                  aes(label=GeneSymbol, color = ann.col),
                  seed = 1581583,
                  direction = "both",
                  force = 600,
                  force_pull = 0,
                  size=1.66,
                  min.segment.length=0.0,
                  segment.size=0.15,
                  segment.color = bclsn.cvnc.qstat.scat.ann.label$ann.col,
                  color = bclsn.cvnc.qstat.scat.ann.label$ann.col,
                  max.overlaps = 50,
                  point.padding = 0.0,
                  fontface="italic")+
  ggtitle(label = "NLT & LT signature in resident CD62L- Treg")+
  xlab(bquote(log[2]~CPM *" ("*spleen*" & "*liver*") (n = 8)"))+
  ylab(bquote(log[2]~CPM *" ("*colon*") (n = 5)"))+
 theme(plot.title = element_text(size = 8, face = "bold"),
        plot.subtitle = element_text(size = 6, face = "bold"),
        axis.title = element_text(size = 8),
        axis.text.x = element_text(size = 6, colour = "black"), #,angle = 90
        axis.text.y =element_text(size = 6, colour = "black"),
        axis.ticks.length.x = unit(0.1,"cm"),
        axis.ticks.length.y = unit(0.1,"cm"),
        axis.ticks = element_line(size=.236),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill = NA,color = "black", size=.236),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.key = element_blank(),
        aspect.ratio = 1)
bclsn.scat.cvnc.nlt.lt
```

* The scatter plot is exported into the figure directory.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3e_TregDGEScatter_cvnc.bn_tmGenes.pdf",
    height=2.6, width = 3.8)
bclsn.scat.cvnc.nlt.lt
dev.off()
```

# GSEA with camera

## Pathway enrichment analysis Hallmark gene sets
* Using camera, we look whether pathways from hallmark gene sets are enriched in our regulated genes
```{r}
library(dplyr)
#hallmark
Mm.H <- readRDS(url("http://bioinf.wehi.edu.au/MSigDB/v7.1/Mm.h.all.v7.1.entrez.rds"))
H.ind.cvnc.bn <- ids2indices(Mm.H, id=dgel.bclsn$genes$EntrezID)
gst.hall.cvnc.bn <- camera.DGEList(dgel.bclsn, index=H.ind.cvnc.bn,
                                     design = bclsn.cvnc.design.dge,
                                     contrast = bclsn.cvnc.con,
                                     inter.gene.cor = 0.05)
gst.hall.cvnc.bn.ord<-gst.hall.cvnc.bn  %>% dplyr::arrange(FDR)
gst.hall.cvnc.bn.ord
H.ind.cvnc.bn <- H.ind.cvnc.bn[rownames(gst.hall.cvnc.bn.ord)]
filter(gst.hall.cvnc.bn.ord,FDR < 0.05)
```

## GSEA Barcode Plots (Supplementary Figure 3 f)
* Barcode plot visualizations of selected top ranking terms are shown below.
* HALLMARK_TNFA_SIGNALING_VIA_NFKB
```{r, fig.height=3.2, fig.width=6}
bclsn.cvnc.bc.tnfa %<a-%{
  par(mar=c(4.1,2.1,0.1,0.1))
  barcodeplot(bclsn.cvnc.tr$table$logFC, 
            index=H.ind.cvnc.bn[["HALLMARK_TNFA_SIGNALING_VIA_NFKB"]],
            labels=c("up in non-colon","colon"), 
            xlab = bquote(log[2]*"FC"),
              col.bars = "peru")
  par(new=TRUE)
  plot.new()
  plot.window( xlim=c(-5,5), ylim=c(-5,5))
  text(-5,4.5,"Brown bars: HALLMARK_TNFA_SIGNALING_VIA_NFKB", adj = c(0,.5))
  text(c(-5,-3.75),c(3.4,3.5),
     c(expression(italic(P)["adj."]*"<"),
       scientific_10x(
         plyr::round_any(
           x = gst.hall.cvnc.bn["HALLMARK_TNFA_SIGNALING_VIA_NFKB",]$FDR,
           accuracy = 10^(ceiling(
             log10(gst.hall.cvnc.bn["HALLMARK_TNFA_SIGNALING_VIA_NFKB",]$FDR))-2),
           f = ceiling),
         digits = 1)), adj = c(0,.5))
}
bclsn.cvnc.bc.tnfa
```

* Barcode plot exported.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3f_Barcodeplot_cvnc.bas.neg_Hallmark_TNFA.pdf", height=3.2, width=6)
bclsn.cvnc.bc.tnfa
dev.off()
```

* HALLMARK_IL6_JAK_STAT3_SIGNALING

```{r, fig.height=3.2, fig.width=6}
bclsn.cvnc.bc.il6js %<a-%{
  par(mar=c(4.1,2.1,0.1,0.1))
  barcodeplot(bclsn.cvnc.tr$table$logFC, 
            index=H.ind.cvnc.bn[["HALLMARK_IL6_JAK_STAT3_SIGNALING"]],
            labels=c("up in non-colon","colon"), 
            xlab = bquote(log[2]*"FC"),
              col.bars = "peru")
  par(new=TRUE)
  plot.new()
  plot.window( xlim=c(-5,5), ylim=c(-5,5))
  text(-5,4.5,"Brown bars: HALLMARK_IL6_JAK_STAT3_SIGNALING", adj = c(0,.5))
  text(c(-5,-3.75),c(3.4,3.5),
     c(expression(italic(P)["adj."]*"<"),
       scientific_10x(
         plyr::round_any(
           x = gst.hall.cvnc.bn["HALLMARK_IL6_JAK_STAT3_SIGNALING",]$FDR,
           accuracy = 10^(ceiling(
             log10(gst.hall.cvnc.bn["HALLMARK_IL6_JAK_STAT3_SIGNALING",]$FDR))-2),
           f = ceiling),
         digits = 1)), adj = c(0,.5))
}
bclsn.cvnc.bc.il6js
```

* Barcode plot exported.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3f_Barcodeplot_cvnc.bas.neg_Hallmark_IL6JS.pdf", height=3.2, width=6)
bclsn.cvnc.bc.il6js
dev.off()
```

* HALLMARK_IL2_STAT5_SIGNALING

```{r, fig.height=3.2, fig.width=6}
bclsn.cvnc.bc.il2s5%<a-%{
  par(mar=c(4.1,2.1,0.1,0.1))
  barcodeplot(bclsn.cvnc.tr$table$logFC, 
            index=H.ind.cvnc.bn[["HALLMARK_IL2_STAT5_SIGNALING"]],
            labels=c("up in non-colon","colon"), 
            xlab = bquote(log[2]*"FC"),
              col.bars = "peru")
  par(new=TRUE)
  plot.new()
  plot.window( xlim=c(-5,5), ylim=c(-5,5))
  text(-5,4.5,"Brown bars: HALLMARK_IL2_STAT5_SIGNALING", adj = c(0,.5))
  text(c(-5,-3.75),c(3.4,3.5),
     c(expression(italic(P)["adj."]*"<"),
       scientific_10x(
         plyr::round_any(
           x = gst.hall.cvnc.bn["HALLMARK_IL2_STAT5_SIGNALING",]$FDR,
           accuracy = 10^(ceiling(
             log10(gst.hall.cvnc.bn["HALLMARK_IL2_STAT5_SIGNALING",]$FDR))-2),
           f = ceiling),
         digits = 1)), adj = c(0,.5))
}
bclsn.cvnc.bc.il2s5
```

* Barcode plot exported.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3f_Barcodeplot_cvnc.bas.neg_Hallmark_IL2STAT5.pdf", height=3.2, width=6)
bclsn.cvnc.bc.il2s5
dev.off()
```

* HALLMARK_INFLAMMATORY_RESPONSE

```{r, fig.height=3.2, fig.width=6}
bclsn.cvnc.bc.infr %<a-%{
  par(mar=c(4.1,2.1,0.1,0.1))
  barcodeplot(bclsn.cvnc.tr$table$logFC, 
            index=H.ind.cvnc.bn[["HALLMARK_INFLAMMATORY_RESPONSE"]],
            labels=c("up in non-colon","colon"), 
            xlab = bquote(log[2]*"FC"),
              col.bars = "peru")
  par(new=TRUE)
  plot.new()
  plot.window( xlim=c(-5,5), ylim=c(-5,5))
  text(-5,4.5,"Brown bars: HALLMARK_INFLAMMATORY_RESPONSE", adj = c(0,.5))
  text(c(-5,-3.75),c(3.4,3.5),
     c(expression(italic(P)["adj."]*"<"),
       scientific_10x(
         plyr::round_any(
           x = gst.hall.cvnc.bn["HALLMARK_INFLAMMATORY_RESPONSE",]$FDR,
           accuracy = 10^(ceiling(
             log10(gst.hall.cvnc.bn["HALLMARK_INFLAMMATORY_RESPONSE",]$FDR))-2),
           f = ceiling),
         digits = 1)), adj = c(0,.5))
}
bclsn.cvnc.bc.infr
```

* Barcode plot exported.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3f_Barcodeplot_cvnc.bas.neg_Hallmark_IR.pdf", height=3.2, width=6)
bclsn.cvnc.bc.infr
dev.off()
```

* Hereafter, the top 4 enriched pathways will be plotted as barcodeplots, FDR ranked.

```{r,fig.height=3.2, fig.width=6}
# for loop for top 4 plotting
for (i in c(1,2,3,4)) {
  #message(i)
    bc.tmp %<a-% {
    par(mar=c(4.1,2.1,0.1,0.1))
    barcodeplot(bclsn.cvnc.tr$table$logFC,
                index=H.ind.cvnc.bn[[i]],
                labels=c("up in non-colon","colon"), 
                xlab = bquote(log[2]*"FC"),
                col.bars = "peru")
    par(new=TRUE)
    plot.new()
    plot.window( xlim=c(-5,5), ylim=c(-5,5))
    text(-5,4.5,paste0("Brown bars: ",names(H.ind.cvnc.bn[i])), adj = c(0,.5))
    text(c(-5,-3.75),c(3.4,3.5),
         c(expression(italic(P)["adj."]*"<"),
           scientific_10x(
             plyr::round_any(
               x = gst.hall.cvnc.bn[i,]$FDR,
               accuracy = 10^(ceiling(
                 log10(gst.hall.cvnc.bn[i,]$FDR))-2),
              f = ceiling),
          digits = 1)), adj = c(0,.5))
  } 
    bc.tmp
}
```

* the arrangement is exported

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3f_Barcodeplot_cvnc.bas.neg_Hallmark_top4ranked.pdf", height = 3.2, width=6)
# for loop for top 4 plotting
for (i in c(1,2,3,4)) {
  #message(i)
    bc.tmp %<a-% {
    par(mar=c(4.1,2.1,0.1,0.1))
    barcodeplot(bclsn.cvnc.tr$table$logFC,
                index=H.ind.cvnc.bn[[i]],
                labels=c("up in non-colon","colon"), 
                xlab = bquote(log[2]*"FC"),
                col.bars = "peru")
    par(new=TRUE)
    plot.new()
    plot.window( xlim=c(-5,5), ylim=c(-5,5))
    text(-5,4.5,paste0("Brown bars: ",names(H.ind.cvnc.bn[i])), adj = c(0,.5))
    text(c(-5,-3.75),c(3.4,3.5),
         c(expression(italic(P)["adj."]*"<"),
           scientific_10x(
             plyr::round_any(
               x = gst.hall.cvnc.bn[i,]$FDR,
               accuracy = 10^(ceiling(
                 log10(gst.hall.cvnc.bn[i,]$FDR))-2),
              f = ceiling),
          digits = 1)), adj = c(0,.5))
  } 
    bc.tmp
}
dev.off()
```

***

# DEG Visualization as Zscore Heat Map
* Hereafter, the heat map shown in Supplementary Figure 3 g will be generated.

## Required Data Frames
* The scaled and prep-batch-corrected data is the data for plotting.
* DGE test statistics are extracted and defined as variables to be extended by logRPKM based on logCPM and gene length.
```{r}
## scaled data for plotting
bclsn.log.cpm.scaled.df <- as.data.frame(bclsn.log.cpm.scaled.cor)
## test statistics for colon vs. non-colon resident Treg
bclsn.treat.heat <- bclsn.cvnc.tr.qstat$table
bclsn.treat.heat$logRPKM <- bclsn.treat.heat$logCPM - log2(bclsn.treat.heat$Length * 0.001)
## test statistics for individual pairwise comparisons
bclsn.lvs.treat.heat <- bclsn.lvs.tr.qstat$table
bclsn.lvs.treat.heat$logRPKM <- bclsn.lvs.treat.heat$logCPM - log2(bclsn.lvs.treat.heat$Length * 0.001)
bclsn.cvl.treat.heat <- bclsn.cvl.tr.qstat$table
bclsn.cvl.treat.heat$logRPKM <- bclsn.cvl.treat.heat$logCPM - log2(bclsn.cvl.treat.heat$Length * 0.001)
bclsn.cvs.treat.heat <- bclsn.cvs.tr.qstat$table
bclsn.cvs.treat.heat$logRPKM <- bclsn.cvs.treat.heat$logCPM - log2(bclsn.cvs.treat.heat$Length * 0.001)
```

## Merging of Data Frames
* Data frames are merged based on a jointly introduced column GeneID.
* Columns relevant for downstream filtering are renamed for clarity.
* Obsolete variables are removed, thereafter.
```{r}
# extend scaled data with GeneID column
bclsn.log.cpm.scaled.df.ext <- bclsn.log.cpm.scaled.df %>% mutate(GeneID = rownames(bclsn.log.cpm.scaled.df))
#extend qstat files with GeneID column
#bclsn.qstat.ext <- bclsn.heat %>% mutate(GeneID = rownames(bclsn.heat))
bclsn.treat.qstat.ext <- bclsn.treat.heat %>% mutate(GeneID = rownames(bclsn.treat.heat)) %>% 
  rename_with(.fn = ~paste0(.,".cvnc"),.cols = c(starts_with("log"),"FDR"))
bclsn.cvl.tr.qstat.ext <- bclsn.cvl.treat.heat %>% mutate(GeneID = rownames(bclsn.cvl.treat.heat)) %>% 
  rename_with(.fn = ~paste0(.,".cvl"),.cols = c(starts_with("log"),"FDR"))
bclsn.cvs.tr.qstat.ext <- bclsn.cvs.treat.heat %>% mutate(GeneID = rownames(bclsn.cvs.treat.heat)) %>% 
  rename_with(.fn = ~paste0(.,".cvs"),.cols = c(starts_with("log"),"FDR"))
bclsn.lvs.tr.qstat.ext <- bclsn.lvs.treat.heat %>% mutate(GeneID = rownames(bclsn.lvs.treat.heat)) %>% 
  rename_with(.fn = ~paste0(.,".lvs"),.cols = c(starts_with("log"),"FDR"))
# merge the tables to the "joint table" (jt)
bclsn.jt<- bclsn.log.cpm.scaled.df.ext %>% 
  inner_join(bclsn.treat.qstat.ext, by ="GeneID") %>%
  inner_join(bclsn.cvl.tr.qstat.ext, by ="GeneID") %>%
  inner_join(bclsn.cvs.tr.qstat.ext, by ="GeneID") %>%
  inner_join(bclsn.lvs.tr.qstat.ext, by ="GeneID")
rownames(bclsn.jt) <- bclsn.jt$GeneID
head(bclsn.jt, n = 4L) 
nrow(bclsn.jt)
# Consistency Check if number of genes is consistent throughout merged objects
length(Reduce(intersect, list(bclsn.log.cpm.scaled.df.ext$GeneID,
                       bclsn.treat.qstat.ext$GeneID,
                       bclsn.cvl.tr.qstat.ext$GeneID,
                       bclsn.cvs.tr.qstat.ext$GeneID,
                       bclsn.lvs.tr.qstat.ext$GeneID)))
# Remove obsolete variables
rm(bclsn.log.cpm.scaled.df.ext,
   bclsn.treat.qstat.ext,
   bclsn.cvl.tr.qstat.ext,
   bclsn.cvs.tr.qstat.ext,
   bclsn.lvs.tr.qstat.ext)
```



## Filter Joint Data Frame for DEGOI
* Hereafter, data is filtered.
* The filtering strategy combines interesting DEGs for the colon vs. non-colon as well as individual pair wise comparisons.
* Also the number of DEGOI for the heat map is printed.
```{r}
# Filtering for DEGOI
bclsn.jt.filtered<-subset(bclsn.jt,
                          # |FC| > 2 in colon vs. non-colon, cvl und cvs with significance and logCPM, logRPKM filter --> colon specific
                          (((logFC.cvnc > 1 & logFC.cvl > 1 & logFC.cvs > 1) | 
                              (logFC.cvnc < -1 & logFC.cvl < -1 & logFC.cvs < -1))
                           & (FDR.cvnc < 0.05 & FDR.cvl < 0.05 & FDR.cvs < 0.05)
                           & (logCPM.cvnc > 1 & logCPM.cvl > 1 & logCPM.cvs > 1)
                           & (logRPKM.cvnc >1 & logRPKM.cvl >1 & logRPKM.cvs > 1))
                          # OR: FC > 2 in lvs & FC < 0.5 in cvl with significance and logCPM, logRPKM filter --> liver specific
                          | (logFC.lvs > 1 & logFC.cvl < -1 & FDR.cvl < 0.05 & 
                               FDR.lvs < 0.05 & logCPM.cvl > 1 & logCPM.lvs > 1 &
                               logRPKM.cvl > 1 & logRPKM.lvs > 1)
                          # OR: FC < 0.5 in lvs & FC < 0.5 in cvs with...--> spleen specific
                          | (logFC.lvs < -1 & logFC.cvs < -1 & FDR.cvs < 0.05 & 
                               FDR.lvs < 0.05 & logCPM.cvs > 1 & logCPM.lvs > 1 & 
                               logRPKM.cvs > 1 & logRPKM.lvs > 1)
                          )
nrow(bclsn.jt.filtered)
```

## Hierarchical Clustering
* The filtered data is hierarchically clustered row as well as column wise.
* Also, colors for the cluster sidebar are defined with the 2 colon-specific clusters combined.
```{r}
# Hierarchical clustering of Zscores based on only the actual Zscores of the samples as matrix
bclsn.hc.filtered <- hclust(dist(t(data.matrix(bclsn.jt.filtered[,metad.bclsn$sample_ID])), method = "manhattan"), method="ward.D")
bclsn.hr.filtered <- hclust(dist(data.matrix(bclsn.jt.filtered[,metad.bclsn$sample_ID]), method = "manhattan"), method="ward.D")
# Marking of the clusters
bclsn.cl.filtered <- cutree(bclsn.hr.filtered, k=5)
bclsn.cl.cols <- c("deeppink4","peru","peru","lightslateblue","cadetblue1")
bclsn.cl.sb.filtered <- bclsn.cl.cols[bclsn.cl.filtered]
# Joint table ordered by ClusterID
bclsn.jt.filtered.clusterID<-cbind(bclsn.jt.filtered,clusterID = bclsn.cl.filtered)
bclsn.jt.filtered.clusterID.ordered <-bclsn.jt.filtered.clusterID[rev(bclsn.hr.filtered$order),]
nrow(bclsn.jt.filtered.clusterID.ordered)
```

## Cluster and Background Gene Lists
* Gene symbols for clusters 1,2,3 and 4 (4 and 5 merged) are extracted in the order of appearance in above heat map from top to bottom.
* Respective background genes resulting from a filtering only by logCPM and logRPKM are defined, as well.
* Additionally, GeneIDs from colon down and up genes are extracted for gene set rotation analyses of respective comparison results in another sample subset.
```{r}
# down in colon, up in spleen and liver
cluster1.genes<-bclsn.jt.filtered.clusterID.ordered$GeneSymbol.x[bclsn.jt.filtered.clusterID.ordered$clusterID %in% unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[1]]
length(cluster1.genes)
# liver specific genes
cluster2.genes<-bclsn.jt.filtered.clusterID.ordered$GeneSymbol.x[bclsn.jt.filtered.clusterID.ordered$clusterID %in% unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[2]]
length(cluster2.genes)
# spleen specific genes
cluster3.genes<-bclsn.jt.filtered.clusterID.ordered$GeneSymbol.x[bclsn.jt.filtered.clusterID.ordered$clusterID %in% unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[3]]
length(cluster3.genes)
# colon specific genes, divided into two clusters in this analysis, hence, combined
cluster4.genes<-bclsn.jt.filtered.clusterID.ordered$GeneSymbol.x[bclsn.jt.filtered.clusterID.ordered$clusterID %in% c(unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[4],unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[5])]
length(cluster4.genes)
# background gene list
bclsn.jt.fil<-subset(bclsn.jt,(logCPM.cvnc > 1 & logCPM.cvl > 1 & logCPM.cvs > 1 & logCPM.lvs > 1) & (logRPKM.cvnc > 1 & logRPKM.cvl > 1  & logRPKM.cvs > 1 & logRPKM.lvs > 1))
bclsn.bg.genes<-bclsn.jt.fil$GeneSymbol.x
length(bclsn.bg.genes)
nrow(bclsn.jt.filtered.clusterID.ordered)
# GeneIDs from colon down and up genes for gene set rotation analyses of respective comparisons in other sample subset
cluster1.geneIDs<-bclsn.jt.filtered.clusterID.ordered$GeneID[bclsn.jt.filtered.clusterID.ordered$clusterID %in% unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[1]]
cluster4.geneIDs<-bclsn.jt.filtered.clusterID.ordered$GeneID[bclsn.jt.filtered.clusterID.ordered$clusterID %in% c(unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[4],unique(bclsn.jt.filtered.clusterID.ordered$clusterID)[5])]
```

## Basic Heat Map (Supplementary Figure 3 g)
* Following filtering for DEGOI and hierarchical clustering of genes and samples, data is presented as heat map.
```{r, fig.height=7.5, fig.width=5.5}
# The following defines the Zscore color code
clustercol <- colorRampPalette(c("blue","white","red"))(29)
col_breaks = c(seq(-1.5,-0.5,length=10), seq(-0.49,0.49,length=10), seq(0.5,1.5,length=10)) 
#plotting of the heat map
bclsn.cvnc.hm.pryr.ann %<a-%{
  heatmap.2(data.matrix(bclsn.jt.filtered[,metad.bclsn$sample_ID]), 
          Rowv=as.dendrogram(bclsn.hr.filtered), 
          Colv=as.dendrogram(bclsn.hc.filtered), 
          col = clustercol, breaks = col_breaks, 
          labRow = FALSE, 
          na.rm=TRUE, 
          margins=c(8,7),  
          cexCol=1, key=TRUE, 
          density.info="none", 
          trace="none", 
          key.title = NA, 
          key.xlab = "Z score",
          lhei=c(1,7),
          #lwid = c(0.25, 0.5),
          RowSideColors = bclsn.cl.sb.filtered,
          main = "DEGs colon vs. other tissues \n |FC| > 2 & FDR < 0.05 \n log2(RPKM) >= 1 & log2(CPM) >= 1")
par(new=TRUE)
plot.new()
plot.window( xlim=c(-5,5), ylim=c(-5,5) )
text(x=-3.3,
     y=2.5,
     col="white",
     cex=0.75,
     labels = length(cluster1.genes),
     srt=90)
text(x=-3.3,
     y=1.2,
     col="white",
     cex=0.75,
     labels = length(cluster2.genes),
     srt=90)
text(x=-3.3,
     y=0.8,
     col="white",
     cex=0.75,
     labels = length(cluster3.genes),
     srt=90)
text(x=-3.3,
     y=-2,
     col="white",
     cex=0.75,
     labels = paste0(length(cluster4.genes)," genes"),
     srt=90)
}
bclsn.cvnc.hm.pryr.ann
```

* which is also exported into the figure directory.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3g_bclsn.Heatmap_indivZscores_qstat.bclsn.treat.lfc.0.6.pdf", height=8.5, width=6.5)
bclsn.cvnc.hm.pryr.ann
dev.off()
```


## Export of gene lists for Metascape
* Cluster and background gene lists are exported for a custom metascape analysis.
* For clusters 1 and 4 (colon up and colon down), GeneIDs are exported additionally for GSEA barcode plots in another analysis.
```{r}
# clusters from hea tmap
write.table(cluster1.genes,
            file = "./ANALDIR/SupplementaryFigure3g_cluster1.colon.down.txt",
            col.names = "GeneSymbol",
            quote=FALSE, 
            row.names = FALSE)
write.table(cluster2.genes,
            file = "./ANALDIR/SupplementaryFigure3g_cluster2.liver.up.txt",
            col.names = "GeneSymbol",
            quote=FALSE, 
            row.names = FALSE)
write.table(cluster3.genes,
            file = "./ANALDIR/SupplementaryFigure3g_cluster3.spleen.up.txt",
            col.names = "GeneSymbol",
            quote=FALSE, 
            row.names = FALSE)
write.table(cluster4.genes,
            file = "./ANALDIR/SupplementaryFigure3g_cluster4.colon.up.txt",
            col.names = "GeneSymbol",
            quote=FALSE, 
            row.names = FALSE)
write.table(bclsn.bg.genes,
            file = "./ANALDIR/SupplementaryFigure3g_filtered.background.genes.txt",
            col.names = "GeneSymbol",
            quote=FALSE, 
            row.names = FALSE)
#additional export for GSEA
write.table(cluster1.geneIDs,
            file = "./ANALDIR/SupplementaryFigure3g_cluster1.colon.down.GeneIDs.txt",
            col.names = "GeneID",
            quote=FALSE, 
            row.names = FALSE)
write.table(cluster4.geneIDs,
            file = "./ANALDIR/SupplementaryFigure3g_cluster4.colon.up.GeneIDs.txt",
            col.names = "GeneID",
            quote=FALSE, 
            row.names = FALSE)
```

* A manual metascape analysis is run with the clusters gene lists customized background gene list.
* Visualization of the results will be done in R, hereafter.

## Metascape Results Bar Plots
* Hereafter, the results of the custom metascape analysis will be visualized.
* Heat map cluster 1: down in colon genes
```{r, fig.width=3.6}
bclsn.metascape.down <- read_excel("./METASCAPE/SupplementaryFigure3g_cluster1.colon.down_metascape_result.xlsx", sheet=2)
bclsn.metascape.down.main <- subset(bclsn.metascape.down, grepl("Summary", bclsn.metascape.down$GroupID))
colnames(bclsn.metascape.down.main) <- c("GroupID","Category","Term","Description","LogP","LogQ","InTerm_InList	Genes","Symbols")
bclsn.metascape.down.main$Description <- factor(bclsn.metascape.down.main$Description, level=bclsn.metascape.down.main$Description)
bclsn.metascape.down.sig <- subset(bclsn.metascape.down.main, LogQ <= log10(0.05))
bclsn.metascape.colon.down.bar <- ggplot(bclsn.metascape.down.sig) + 
    aes(x=Description, y=-LogQ ) + coord_flip() + 
    scale_x_discrete(limits=rev) +
    scale_y_continuous(expand = c(0,0)) +
    geom_bar(stat="identity", fill="lightslateblue") +
    ggtitle(label = "GO colon vs. non-colon", subtitle = "down in colon-resident CD62L- Treg") +
        ylab(bquote(-log[10]~italic(P)[adj.])) + xlab("") +
    theme(plot.title = element_text(size = 8, face = "bold"),
        plot.subtitle = element_text(size = 6, face = "bold"),
        axis.title = element_text(size = 8),
        axis.text.x = element_text(size = 6, colour = "black"), 
        axis.text.y =element_text(size = 6, colour = "black"),
        axis.ticks.length.x = unit(0.1,"cm"),
        axis.ticks.length.y = unit(0.1,"cm"),
        axis.ticks = element_line(size=.236),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill ="white",color = NA),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())
bclsn.metascape.colon.down.bar
```

* Heat map cluster 2: up-in-liver genes
* No terms significantly enriched.
* Heat map cluster 3: up-in-liver genes
* No terms significantly enriched.
* Heat map Cluster 4: up-in-colon genes

```{r, fig.width=3.6}
bclsn.metascape.up <- read_excel("./METASCAPE/SupplementaryFigure3g_cluster4.colon.up_metascape_result.xlsx", sheet=2)
bclsn.metascape.up.main <- subset(bclsn.metascape.up, grepl("Summary", bclsn.metascape.up$GroupID))
colnames(bclsn.metascape.up.main) <- c("GroupID","Category","Term","Description","LogP","LogQ","InTerm_InList	Genes","Symbols")
bclsn.metascape.up.main$Description <- factor(bclsn.metascape.up.main$Description, level=bclsn.metascape.up.main$Description)
bclsn.metascape.up.sig <- subset(bclsn.metascape.up.main, LogQ <= log10(0.05))
bclsn.metascape.colon.up.bar <- ggplot(bclsn.metascape.up.sig[1:10,]) + 
    aes(x=Description, y=-LogQ ) + coord_flip() + 
    scale_x_discrete(limits=rev) +
    scale_y_continuous(expand = c(0,0)) +
    geom_bar(stat="identity", fill="peru") +
    ggtitle(label = "GO colon vs. non-colon", subtitle = "up in colon-resident CD62L- Treg") +
        ylab(bquote(-log[10]~italic(P)[adj.])) + xlab("") +
    theme(plot.title = element_text(size = 8, face = "bold"),
        plot.subtitle = element_text(size = 6, face = "bold"),
        axis.title = element_text(size = 8),
        axis.text.x = element_text(size = 6, colour = "black"), 
        axis.text.y =element_text(size = 6, colour = "black"),
        axis.ticks.length.x = unit(0.1,"cm"),
        axis.ticks.length.y = unit(0.1,"cm"),
        axis.ticks = element_line(size=.236),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill ="white",colour = NA),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        )
bclsn.metascape.colon.up.bar
```

### Pathway analysis (Metascape) (Supplementary Figure 3 h)
* Hereafter, significantly enriched pathways as determined by the custom metascape analysis are presented as bar plots.
* Only for heat map clusters (Supplementary Figure 3 g) 1 and 4, pathways were found enriched significantly.
```{r,fig.height=4.6, fig.width=3.6}
bclsn.metascape.plot.grid <- plot_grid(bclsn.metascape.colon.down.bar,
                                       bclsn.metascape.colon.up.bar,
                                       ncol=1,
                                       align="v",
                                       rel_heights = c(3,4)
                                       )
bclsn.metascape.plot.grid
```

* The figure is also exported.

```{r}
pdf(file="./FIGDIR/SupplementaryFigure3h_bclsn.Metascape.Barplot.pdf", height=5.6, width = 4.6)
bclsn.metascape.plot.grid
dev.off()
```

***

# Additional Subsetting Index for all Baseline samples: CD62L^+^ & CD62L^-^
* For the bar plot in Supplementary Figure 3 i, we also need to include CD62L^+^ samples.
* A subsetting index is created for that purpose.
```{r}
bcls.ind<-grepl("wt",metad.m$appl)&(grepl("S", metad.m$org)|grepl("C", metad.m$org)|grepl("L", metad.m$org))
bcls.ind
```

##Counts

* Here, the comprehensive counts data frame is reduced using the subsetting index.

```{r}
#Subsetting the respective counts object (counts.m)
counts.bcls<-counts.m[,bcls.ind]
ncol(counts.bcls)
colnames(counts.bcls)
```
## Metadata
* The metadata has to be reduced accordingly. 
* The original order of samples is introduced for downstream re-ordering of the read count table.
* An additional, custom group variable is introduced as well. 
```{r, echo= FALSE}
metad.bcls<-metad.m[bcls.ind,]
metad.bcls$orig.ord<-1:nrow(metad.bcls)
metad.bcls<-metad.bcls[order(metad.bcls$appl),] #maybe think of something notowing the order to be customized here
counts.bcls.ind<-metad.bcls$orig.ord
metad.bcls
group.bcls<-factor(as.character(metad.bcls$grp), levels = c("wt_C_neg","wt_L_neg","wt_S_neg","wt_L_pos","wt_S_pos"))
```
## Re-ordering Counts Data Frame Columns
* Here, read counts are re-ordered according to the metadata object.
```{r}
counts.bcls.ord<-counts.bcls[,counts.bcls.ind]
head(counts.bcls.ord)
counts.bcls<-counts.bcls.ord
rm(counts.bcls.ord)
```
## Consistency Check
* In order to avoid wrongful labelling, sample_IDs are used to confirm that the counts and metadata objects are consistent.
```{r}
if (sum(colnames(counts.bcls)==metad.bcls$sample_ID)==sum(bcls.ind)) {
  print("Counts and metadata are properly subsetted and in accordance with each other. The analysis can be proceeded with!")
}else {
  print("Something is inconsistent, check the code above for errors during subsetting!")
}
```
## DGE List Objects
* A DGEList object is generated, the main class of the edgeR package. 
* For full functionality, the counts.bcls, group.bcls and genes.df variables are used to do so.
```{r,include=FALSE}
dgel.bcls<-DGEList(counts = counts.bcls, group = group.bcls, genes = genes.df)
dgel.bcls
dgel.bcls$samples
```

## Exclusion of Rare Transcripts
* The "filterByExpr()" function is used to determine which genes have sufficiently large counts to be retained in a statistical analysis. 
* Only genes fulfilling that criterion are kept and also normalization factors are calculated.
```{r}
keep.bcls <- filterByExpr(dgel.bcls)
dgel.bcls <- dgel.bcls[keep.bcls, , keep.lib.sizes=FALSE]
dgel.bcls <- calcNormFactors(dgel.bcls)
table(keep.bcls)
dgel.bcls$samples
```
## Log~2~(rpkm) Calculation
* In this step, Log~2~(rpkm) are calculated.
* Also, for the data plotted, a prep-batch correction is carried out.
```{r}
# log2rpkm values with a prior count of 2
bcls.log.rpkm <- rpkm(dgel.bcls, prior.count = 2,log = TRUE)
# design with the group identity preserved
design.bcls<-model.matrix(~0+group.bcls)
bcls.log.rpkm.cor <-removeBatchEffect(bcls.log.rpkm, batch = metad.bcls$pb,
                                      design = design.bcls)
```

***

# Barplots for Gene Expression Levels
* log2-transformed RPKM bar plots for selected genes are produced by the following code.
* Before bar plots can be generated, an appropriate data frame has to be created.

## Aesthetics
* Fitting color and shapes vectors have to be defined for aesthetic plotting.

### Named Color Vector
* A named color vector is defined, hereafter.
```{r}
bcls.col<-c("peru","lightsteelblue","hotpink4","lightsteelblue1","hotpink")
names(bcls.col)<-levels(group.bcls)
bcls.col
```

### Named Shapes Vector
* A named shapes vector is defined, in the following.
```{r}
bcls.shp.3<-c(23,24,21,24,21)
names(bcls.shp.3)<-levels(group.bcls)
bcls.shp.3
```

## Definition of GOI
* Hereafter, we define genes of interest (GOI) for downstream bar plots.
* GOI comprise organ specific genes, defined as one vector.
```{r}
organ.sig<-c("Cxcr5","Izumo1r","Naip5","Naip6","S1pr1","S1pr4","Cd55","Klf2","Klrg1","Il1rl1","Gpr15","Relb")
organ.sig
```

## Data Preparation

### Transposed Data Frame 
* Hereafter, a transposed log~2~(rpkm) data frame is generated.
* This is done for the defined GOI with gene symbols used as rownames.
```{r}
bcls.log.rpkm.4bar <- data.frame(bcls.log.rpkm.cor)
bcls.log.rpkm.an <- as.data.frame(strsplit2(rownames(bcls.log.rpkm),"[$]"))
# introduce GeneSymbol column
bcls.log.rpkm.4bar$GeneSymbol <- bcls.log.rpkm.an$V2
# subsetting for GOI
bcls.log.rpkm.4bar.organ <- bcls.log.rpkm.4bar[bcls.log.rpkm.4bar$GeneSymbol %in% organ.sig, ]
# GeneSymbols become row names
rownames(bcls.log.rpkm.4bar.organ) <- bcls.log.rpkm.4bar.organ$GeneSymbol
# the matrix is transposed
bcls.log.rpkm.4bar.organ.tp <- t(bcls.log.rpkm.4bar.organ)
# the GeneSymbol row after transposing is removed
bcls.log.rpkm.4bar.organ.tp <- as.data.frame(bcls.log.rpkm.4bar.organ.tp[rownames(bcls.log.rpkm.4bar.organ.tp) != "GeneSymbol", , drop = FALSE])
```

### Annotation and Gathering for Bar plot Data frame
* SampleID, group information is added.
* Individual observations are summarized per sample group and GOI.
* Values are converted to numeric and the GeneSymbol column is declared a factor to enable desirable ordering.
```{r}
bcls.log.rpkm.4bar.organ.tp$sampleID<-colnames(counts.bcls)
bcls.log.rpkm.4bar.organ.tp$group<-group.bcls
bcls.log.rpkm.4bar.organ.dm <- gather(bcls.log.rpkm.4bar.organ.tp, key = "GeneSymbol", value="rpkm",
all_of(organ.sig))
bcls.log.rpkm.4bar.organ.dm$rpkm <- as.numeric(as.character(bcls.log.rpkm.4bar.organ.dm$rpkm))
bcls.log.rpkm.4bar.organ.dm$GeneSymbol <- factor(as.character(bcls.log.rpkm.4bar.organ.dm$GeneSymbol), levels = c("Cxcr5","Izumo1r","Naip5","Naip6","S1pr1","S1pr4","Cd55","Klf2","Klrg1","Il1rl1","Gpr15","Relb"))
sapply(bcls.log.rpkm.4bar.organ.dm, class)
```

## Bar plot arrangement (Supplementary Figure 3 i)
* Bar plots are created and arranged into an array of plots.
* Scale labeling is adjusted to match the manual data transformation for more aesthetic plotting.
```{r}
bar.plot.organ<-ggplot(data = bcls.log.rpkm.4bar.organ.dm,
                       aes(x = group,
                           y = 2^(rpkm+4),
                           fill = group,
                           shape = group))+
  coord_cartesian(clip = "off")+
  scale_y_continuous(trans = log2_trans(),
                     expand = c(0.01,0),
                     limits = c(1,16384),
                     breaks = c(1,4,16,64,256,1024, 4096,16384),
                     labels = trans_format(trans = function(x) log2(x)-4,
                                           format = math_format(2^.x)))+
  annotation_logticks(outside = T,
                      sides = "l",
                      short = unit(0.01,"mm"),
                      mid = unit(.5,"mm"),
                      long = unit(1,"mm"),
                      size=.236)+
  stat_summary(fun=mean,
               geom="col",
               position = "dodge",
               width = 0.75,
               alpha=0.5)+
  geom_point(size=1,
             stroke=.236,
             colour = "black",
             position = position_jitterdodge(jitter.width=2.0,
                                             dodge.width = 1.0,
                                             seed = 1234))+
  stat_summary(fun.data = mean_se,
               fun.args = list(mult=1),
               geom = "errorbar",
               color ="black",
               linetype = "solid",
               size=0.25,
               width=0.8,
               position = "dodge")+
  scale_fill_manual(values = alpha(bcls.col,0.75))+
  scale_colour_manual(values = alpha(bcls.col,0.50))+
  scale_shape_manual(values = bcls.shp.3)+
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 8, face = "bold", colour = "black"),
        axis.title.y = element_text(size = 8, colour = "black"),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_text(size = 6, colour = "black", angle = 90, hjust=1, vjust=0.5),
        axis.text.y = element_text(size = 6, colour = "black"),
        axis.ticks = element_line(size=.236),
        axis.line = element_line(size=.236),
        strip.background = element_blank(),
        strip.text = element_text(size = 8, face = "italic",color = "black"),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill = NA,color = "black", size=.236),
        panel.border = element_rect(colour = "black", fill=NA, size=.236),
        legend.position = "none")+
  labs(x="Treg group",
       y = "Reads per kilobase per million (RPKM)") +
  facet_wrap(~GeneSymbol, ncol = 4)
```

* The plot array is shown, hereafter.  

```{r, fig.width=2.5, fig.height=3.5}
bar.plot.organ
```

* The bar plot arrangement is exported, hereafter.

```{r}
pdf(file = "./FIGDIR/SupplementaryFigure3i_bcls.organ.sig.barplots.expression.shifted+4.prepbatch-corrected.pdf",
   width = 2.5, height = 3.5)
bar.plot.organ
dev.off()
```

***

# SessionInfo
```{r, echo=FALSE, warning=FALSE}
sessionInfo(package = NULL)
writeLines(capture.output(sessionInfo(package = NULL)), "./Rscripts/Figure3_TregDGEScatter_GSEA_Heatmap_Metascape_cvnc.b.Cd62Lneg_SessionInfo.txt")
```

***

# Bibliography
