---
title: "Figure3_UMAP_Barplots_pcbd"
subtitle: "UMAP embedding of donor and re-isolated Treg (noBMT, BMTw/oTconv,BMTwTconv) as well as log2RPKM Barplots for selected genes."
author: "David Dittmar"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    fig_caption: yes
    number_sections: no
    toc: yes
    toc_float: yes
    code_folding: hide 
---

***

```{r setup, include=FALSE}
# Set global chunk options
knitr::opts_chunk$set(echo = TRUE, include = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
# ...packages.bib file is also written here
knitr::write_bib(.packages(), "Figure1_TregSigHeatmap_fresh.allo.poly_packages.bib")
```

```{r}
# Load required counts, metadata and annotaion RDS files
counts.m.rm<-readRDS("./RCTDIR/counts.m.rm.2021-06-09.rds")
metad.m.rm<-readRDS("./METADIR/metad.m.rm.2021-06-09.rds")
stid<-readRDS("./METADIR/stid_2020-12-21.rds")
```

```{r, include=FALSE}
# Load required libraries
library(edgeR)
library(AnnotationDbi)
library(org.Mm.eg.db) #for mouse
library(ggplot2)
library(ggrepel)
library(dplyr)
library(tibble)
library(reshape2)
library(scales)
```
* First, required data objects (counts, metadata, short transcript ID) and R packages are loaded. 
* This is the starting point for most analyses conducted on bulk RNA-seq data for the associated manuscript.

***

# Data Preparation
* For the analysis, the data and metadata have to be prepared and properly annotated.

### Annotation Data Frame
* An annotation data frame with 4 columns is constructed.
* The additional EntrezID column is required for possible downstream pathway analyses or annotation operations.
```{r}
genes.df<-as.data.frame(strsplit2(stid,"[$]"))
colnames(genes.df)<-c("EnsemblID","GeneSymbol","Length","GeneType")
genes.df$EnsemblID<-as.character(genes.df$EnsemblID)
genes.df$GeneSymbol<-as.character(genes.df$GeneSymbol)
genes.df$Length<-as.numeric(as.character(genes.df$Length))
genes.df$GeneType<-as.character(genes.df$GeneType)
genes.df$EntrezID<- mapIds(org.Mm.eg.db,
                    keys=genes.df$GeneSymbol,
                    column="ENTREZID",
                    keytype="SYMBOL",
                    multiVals="first")
rownames(genes.df)<-stid
head(genes.df, n=5L)
#See if the gene length values are still as they should, so this should yield an empty vector
which(strsplit2(stid,"[$]")[,3] %in% genes.df$Length==FALSE)
```

## Subsetting Index
* In this analysis, we focus on resident Treg and donor Treg re-isolated from recipient organs 7d after transfer (BMT w/o Tconv & BMT w Tconv).
* A subsetting index is generated accordingly.
```{r}
pcbd.ind<-grepl(pattern = "the",x=metad.m.rm$appl)|grepl(pattern = "P",x=metad.m.rm$org)|grepl(pattern = "I",x=metad.m.rm$org)|grepl(pattern = "B",x=metad.m.rm$org)
pcbd.ind<-pcbd.ind==F
pcbd.ind
sum(pcbd.ind)
```

## Counts
* Here, the comprehensive counts data frame is reduced using the subsetting index.
```{r}
#Subsetting the respective counts object (counts.m.rm)
counts.pcbd<-counts.m.rm[,pcbd.ind]
paste(ncol(counts.pcbd),"samples are selected:")
colnames(counts.pcbd)
```

## Metadata
* The metadata has to be reduced accordingly. 
* The original order of samples is introduced for downstream re-ordering of the read count table.
* A graspable group variable is introduced, as well.
```{r, echo= FALSE}
metad.pcbd<-metad.m.rm[pcbd.ind,]
metad.pcbd$orig.ord<-1:nrow(metad.pcbd)
metad.pcbd<-metad.pcbd[order(metad.pcbd$grp),]
counts.pcbd.ind<-metad.pcbd$orig.ord
#the whole group description
group.pcbd<-factor(as.character(metad.pcbd$grp), 
                  levels = c("d_a","d_p",
                             "pro_C_a","pro_C_p","prc_C_a","prc_C_p","wt_C_neg",
                             "pro_L_a","pro_L_p","prc_L_a","prc_L_p","wt_L_neg","wt_L_pos",
                             "pro_S_a","pro_S_p", "prc_S_a","prc_S_p","wt_S_neg","wt_S_pos"))
```

### Re-ordering Counts Data Frame Columns
* Here, read counts are re-ordered according to the metadata object.
```{r}
counts.pcbd.ord<-counts.pcbd[,counts.pcbd.ind]
head(counts.pcbd.ord, n=4L)
counts.pcbd<-counts.pcbd.ord
rm(counts.pcbd.ord)
```

## Consistency Check
* In order to avoid wrongful labelling, sample_IDs are used to confirm that the counts and metadata objects are consistent.
```{r}
if (sum(colnames(counts.pcbd)==metad.pcbd$sample_ID)==sum(pcbd.ind)) {
  print("Counts and metadata are properly subsetted and in accordance with each other. The analysis can be proceeded with")
}else {
  print("Something is inconsistent, check the code above for errors during subsetting!")
}
```

## DGE List Object
* A DGEList object is generated, the main class of the edgeR package. 
* For full functionality, the counts.pcbdt, group.avp.pcbdt and genes.df variables are used to do so.
```{r}
dgel.pcbd<-DGEList(counts = counts.pcbd, group = group.pcbd, genes = genes.df)
head(dgel.pcbd$counts, n=4L)
head(dgel.pcbd$samples, n=4L)
head(dgel.pcbd$genes, n=4L)
```

### Exclusion of Rare Transcripts
* We filter for transcripts with cpm > 1 in at least 8 samples.
* Only genes fulfilling that criterion are kept and also normalization factors are calculated.

```{r}
keep.pcbd <- rowSums(cpm(dgel.pcbd)>1) >= 8 
dgel.pcbd <- dgel.pcbd[keep.pcbd, , keep.lib.sizes=FALSE]
dgel.pcbd <- calcNormFactors(dgel.pcbd)
print(paste(table(keep.pcbd)[1],"genes are discarded while",table(keep.pcbd)[2], "genes are retained in the analysis!"))
```

## Raw CPM, LOG.CPM, RPKM, LOG.RPKM & Zscores

* In this step, counts per million (cpm), log2(cpm), reads per kilobase per million (rpkm), log2(rpkm) and respecitve scaled data are computed.
* This will generate all non-batch-corrected data matrices for downstream visualizations.

```{r}
#cpm and log.cpm
pcbd.raw.cpm <- cpm(dgel.pcbd, normalized.lib.sizes = TRUE) #non-log-transformed cpms are calculated starting from dgel.pcbd$counts AFTER normalization and filtering
pcbd.log.cpm <- cpm(dgel.pcbd, prior.count = 2, log = TRUE) #log-transformed cpms with a prior count of 2
#Zscore transformation of log.cpms
pcbd.log.cpm.scaled.transposed<-(scale(t(pcbd.log.cpm)))
pcbd.log.cpm.scaled<-data.matrix(t(pcbd.log.cpm.scaled.transposed))
rm(pcbd.log.cpm.scaled.transposed)
#rpkm and log rpkm
pcbd.raw.rpkm <- rpkm(dgel.pcbd, normalizepcbd.lib.sizes = TRUE)
pcbd.log.rpkm <- rpkm(dgel.pcbd, prior.count = 2,log = TRUE)
```

## Batch-corrected CPM, LOG.CPM, RPKM, LOG.RPKM & Zscores

Depending on the subset, different options for batch-correction are enabled.

### Creating batch & empty lists

We want to correct for PCR2 cycle number and RNA input-category (max./non-max.) in this case.

```{r, include=FALSE, echo=FALSE}
#creating a list of the batches to be evaluated
pcbd.batch.l<-list(metad.pcbd$PCR2.Cy, metad.pcbd$incat)
names(pcbd.batch.l)<-c("PCR2CyNo", "input-category")
#creating a design for plotting, only containing the differences to be conserved
pcbd.design.plots <- model.matrix(~group.pcbd)
#first, we need an empty list object which will later contain all corr.log.cpm variables
pcbd.log.cpm.cor.l<-list()#
#newly introduced for rpkms and deducted variables
pcbd.log.cpm.scaled.cor.l<-list()
pcbd.log.rpkm.cor.l<-list()

```

After having created empty lists for the batch-corrected variables and having defined the kinds of batches to correct for, we can now iteratively apply the batch-correction using the "removeBatchEffect()" function. Importantly, by also supplying a design which contains the differences that should be kept, based on the Treg group in that particular case, we make sure no interesting biological effects are removed.

### Actual batch-correction
```{r}
#now, we can fill this list with corrected variables for each batch
for (i in 1:length(pcbd.batch.l)) {
  print(names(pcbd.batch.l)[i]) #just show the name of the batch so in the end you know what worked and what did not
  #batch correction for the log.cpms and deduction of the respective zscore
  
  pcbd.log.cpm.cor.l[[paste("pcbd.log.cpm.cor",names(pcbd.batch.l)[i],sep = ".")]]<-removeBatchEffect(pcbd.log.cpm,batch = pcbd.batch.l[[i]],design = pcbd.design.plots)
  transposed<-(scale(t(pcbd.log.cpm.cor.l[[i]])))
  pcbd.log.cpm.scaled.cor.l[[paste("pcbd.log.cpm.scaled.cor",names(pcbd.batch.l)[i],sep = ".")]]<-data.matrix(t(transposed))
  #batch correction of the log.rpkms and deduction of the respective zscore
  pcbd.log.rpkm.cor.l[[paste("pcbd.log.rpkm.cor",names(pcbd.batch.l)[i],sep = ".")]]<-removeBatchEffect(pcbd.log.rpkm,batch = pcbd.batch.l[[i]],design = pcbd.design.plots)
  }
rm(transposed)
```
Ok, the batch correction for the listed variables went without an error.

# Aesthetics Vectors
* The definition of aesthetics vectors as named vectors is useful for proper labeling in downstream plots.

## Named Color Vector
* Hereafter, colors are defined that are consistently used for groups throughout the manuscript.
```{r}
pcbd.col<-c("red","firebrick",
            "sienna","sienna3",
            "chocolate4","chocolate3",
            "peru",
            "steelblue","steelblue1",
            "dodgerblue3","dodgerblue",
            "lightsteelblue","lightsteelblue1",
            "deeppink4","deeppink",
            "magenta3","magenta",
            "hotpink4","hotpink")
names(pcbd.col)<-levels(group.pcbd)
pcbd.col
```

## Named Shape Vector
* Also, for shapes a vector is required.
```{r}
pcbd.shp.4<-c(rep(22,2),
              23,23,24,24,21,
              rep(c(23,23,24,24,21,21),2))
names(pcbd.shp.4)<-levels(group.pcbd)
pcbd.shp.4
```
## Legend Labels with correct replicate count
* Following, legend labels are defined that also comprise the correct replicate count, based on the actual data structure used.
```{r}
pcbd.lab<-c(#donor 
           paste0("donor, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[1],]),")"),
           paste0("donor, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[2],]),")"),
           #colon
           paste0("prophylaxis, colon, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[3],]),")"),
           paste0("prophylaxis, colon, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[4],]),")"),
           paste0("transplant control, colon, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[5],]),")"),
           paste0("transplant control, colon, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[6],]),")"),
           paste0("organ-resident, colon, CD62L- (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[7],]),")"),
           #liver
           paste0("prophylaxis, liver, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[8],]),")"),
           paste0("prophylaxis, liver, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[9],]),")"),
           paste0("transplant control, liver, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[10],]),")"),
           paste0("transplant control, liver, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[11],]),")"),
           paste0("organ-resident, liver, CD62L- (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[12],]),")"),
           paste0("organ-resident, liver, CD62L+ (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[13],]),")"),
           #spleen 
           paste0("prophylaxis, spleen, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[14],]),")"),
           paste0("prophylaxis, spleen, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[15],]),")"),
           paste0("transplant control, spleen, allo (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[16],]),")"),
           paste0("transplant control, spleen, poly (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[17],]),")"),
           paste0("organ-resident, spleen, CD62L- (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[18],]),")"),
           paste0("organ-resident, spleen, CD62L+ (n=",nrow(metad.pcbd[metad.pcbd$grp==levels(group.pcbd)[19],]),")")
           )
names(pcbd.lab)<-levels(group.pcbd)
pcbd.lab
```



# Uniform Manifold Aproximation and Projection (UMAP)

## UMAP Function
* Hereafter, a convenience function for direct UMAP plotting is defined.
```{r}
#updated 2021-05-23
umap_func<-function(data=NULL,
                    seed=1234,
                    xlim=range(umap.dat$X1),
                    n.x.breaks=10,
                    ylim=range(umap.dat$X2),
                    n.y.breaks=10,
                    plot.tag="no tag",
                    title="no title",
                    title.pos="panel",
                    caption="no caption",
                    group=rep("group",ncol(data)),
                    group.labels=levels(as.factor(rep("group",ncol(data)))),
                    group.labelsize=10,
                    data.labels=colnames(data),
                    data.labelsize=5,
                    basesize=10,
                    pchsize=3,
                    fill.colors=c("group"="black"),
                    fill.alpha=rep(1.0,ncol(data)),
                    colour.colors=c("group"="black"),
                    colour.alpha=rep(1.0,ncol(data)),
                    shapes=c("group"=21),
                    leg.pos="right"){
  #set seed for reproducibility
  set.seed(seed = seed)
  #appply umap algorithm on transposed data matrix, then extract layout for plotting
  umap.dat<-umap::umap(t(as.matrix(data)))
  umap.dat<-data.frame(umap.dat$layout)
  #generate ggplot object
  umap.p<-ggplot(data = umap.dat)+
    aes(x = X1, y = X2, shape = group, fill = group, colour = group)+
    scale_x_continuous(limits = xlim,
                       n.breaks = n.x.breaks) +
    scale_y_continuous(limits = ylim,
                       n.breaks = n.y.breaks)+
    xlab("UMAP2") + 
    ylab("UMAP1") +
    geom_point(size = pchsize)+
    scale_colour_manual(values = alpha(colour.colors[group],colour.alpha),  #here, you manually adjust the colors of the data points and the legend alike
                        name  ="Treg Group", #legend title
                        labels=group.labels) + # adjust the legend label if desired
    scale_fill_manual(values = alpha(fill.colors[group],fill.alpha),
                      name = "Treg Group",
                      labels = group.labels)+
    scale_shape_manual(values = shapes[group],
                       name = "Treg Group",
                       labels = group.labels)+
    geom_text_repel(aes(label=data.labels), 
                    size=data.labelsize,
                  segment.size=0.2, 
                  min.segment.length=0.0, 
                  point.padding=.05, 
                  segment.alpha=0.5,
                  max.overlaps = 50,
                  force = 50,
                  show.legend = FALSE) +
    labs(title = title,tag = plot.tag, caption = caption)+
    theme_light(base_size=basesize) + 
    theme(plot.tag=element_text(size = basesize*2.0, face = "bold"),
          plot.title = element_text(size = basesize, face = "bold"),
          plot.title.position = title.pos,
          legend.text = element_text(colour="black", size = group.labelsize, face = "plain"),
          legend.title = element_text(colour="black", size = group.labelsize, face = "bold"),
          legend.box.just = "top",
          axis.text = element_text(colour = "black", size = basesize, face = "plain"),
          axis.title = element_text(colour = "black",size = basesize,face = "plain"),
          panel.grid = element_blank(),
          panel.border = element_rect(colour = "black"),
          axis.ticks = element_line(colour="black"),
          aspect.ratio = 1.0, #plot panel aspect ratio for squared == 1.0! :) 
          legend.position = leg.pos
        )
  plot(umap.p)
}
```

## UMAP Plot (Figure 3 a)
* Following, a UMAP plot is generated based on the log2(CPM) values of selected samples.
* At the same time, batch-correction for the number of pcr2 cycles applied during library prep is performed.
```{r, fig.width=8.875, fig.height=5.175}
umap_func(data = pcbd.log.cpm.cor.l$pcbd.log.cpm.cor.PCR2CyNo,
                        seed = 13,
                        xlim = c(-10,12),
                        n.x.breaks = 6,
                        ylim = c(-8,6),
                        n.y.breaks = 6, 
                        plot.tag="a",
                        title = "Donor Treg expression profiles",
                        title.pos = "panel",
                        group = group.pcbd,
                        group.labels = pcbd.lab,
                        group.labelsize = 14,
                        data.labels = "",
                        data.labelsize = 6,
                        basesize = 16,
                        pchsize = 2.5,
                        fill.colors = pcbd.col,
                        fill.alpha = 0.5,
                        colour.colors = pcbd.col,
                        colour.alpha = 1,
                        shapes = pcbd.shp.4,
                        leg.pos = "right",
          caption = "batch-correction for pcr2 cycle number applied")
```

* The plot is also exported into the figure directory.
```{r}
pdf(file = "./FIGDIR/Figure3_UMAP_pcbd.pdf",
    width = 8.875, 
    height = 5.175)
umap_func(data = pcbd.log.cpm.cor.l$pcbd.log.cpm.cor.PCR2CyNo,
                        seed = 13,
                        xlim = c(-10,12),
                        n.x.breaks = 6,
                        ylim = c(-8,6),
                        n.y.breaks = 6, 
                        plot.tag="a",
                        title = "Donor Treg expression profiles",
                        title.pos = "panel",
                        group = group.pcbd,
                        group.labels = pcbd.lab,
                        group.labelsize = 14,
                        data.labels = "",
                        data.labelsize = 6,
                        basesize = 16,
                        pchsize = 2.5,
                        fill.colors = pcbd.col,
                        fill.alpha = 0.5,
                        colour.colors = pcbd.col,
                        colour.alpha = 1,
                        shapes = pcbd.shp.4,
                        leg.pos = "right",
          caption = "batch-correction for pcr2 cycle number applied")
dev.off()
```

# Barplots for Gene Expression Levels
* log2-transformed RPKM barplots for selected genes are produced by the following code.
* Before barplots can be generated, an appropriate data frame has to be created.

## Additional Metadata Vectors
* For grouping in the plots, we want to have multiple options for stratification. 
* So, we need the group, only the organ, only the setting and the expansion mode for the Treg prior Tx plus Sell+/- for physiolgically tissue-resident Treg. 
* Also, we can adjust the levels here, so the order of samples in the plots will be to our liking. For now I choose prophylaxis -> control -> baseline as order.
```{r}
#only setting and allo/poly or Sell+/-
appl.treat.pcbd<-factor(c(as.character(c(rep("d_a",6),rep("d_p",6))),
                        as.character(paste0(metad.pcbd$appl,"_",metad.pcbd$treat))[13:length(paste0(metad.pcbd$appl,"_",metad.pcbd$treat))]),
                       levels = c("d_a","d_p","pro_a","pro_p","prc_a","prc_p","wt_neg","wt_pos"))
appl.treat.pcbd
#only organ 
org.pcbd<-factor(as.character(metad.pcbd$org))
org.pcbd
```

## Transposed Individual Observations and Annotation
* Individual observations are transposed and properly annotated, hereafter.
* This is an essential step in preparing the data for the melt() function of the reshape2 package.
```{r, warning=FALSE}
#We choose log.rpkm values corrected for pcr2 cy no. for the values to be visualized
pcbd.log.rpkm.df.tp<-as.data.frame(t(pcbd.log.rpkm.cor.l$pcbd.log.rpkm.cor.PCR2CyNo)) %>%
  tibble::rownames_to_column() %>%
  as_data_frame()
#we need a gene symbol annotation based on the column names, which are the short transcript ID entries at the moment
pcbd.log.rpkm.df.tp.an<-as.data.frame(strsplit2(colnames(pcbd.log.rpkm.df.tp),"[$]"))
colnames(pcbd.log.rpkm.df.tp)<-pcbd.log.rpkm.df.tp.an$V2
colnames(pcbd.log.rpkm.df.tp)[1]<-"sample_ID"
#rownames(pcbd.log.rpkm.df.tp)<-pcbd.log.rpkm.df.tp$sample_ID #setting row names to a tibble is deprecated
#Addition of metadata columns
pcbd.log.rpkm.df.tp<-add_column(pcbd.log.rpkm.df.tp, "group"= group.pcbd, .after = "sample_ID")
pcbd.log.rpkm.df.tp<-add_column(pcbd.log.rpkm.df.tp,"appl.exp"=appl.treat.pcbd, .after ="group" )
pcbd.log.rpkm.df.tp<-add_column(pcbd.log.rpkm.df.tp, "organ"= org.pcbd, .after = "appl.exp")
pcbd.log.rpkm.df.tp<-add_column(pcbd.log.rpkm.df.tp, "color" = as.factor(pcbd.col[group.pcbd]), .after = "organ")
pcbd.log.rpkm.df.tp<-add_column(pcbd.log.rpkm.df.tp,"shape"=as.factor(pcbd.shp.4[group.pcbd]), .after = "color")
head(pcbd.log.rpkm.df.tp, n=4L)
tail(pcbd.log.rpkm.df.tp, n=4L)
```

## Consistency Check
* Here, a quick consistency check is performed.
```{r}
sum(pcbd.log.rpkm.df.tp$sample_ID == metad.pcbd$sample_ID)
sum(pcbd.log.rpkm.df.tp$group == group.pcbd)
sum(pcbd.log.rpkm.df.tp$organ == metad.pcbd$org)
sum(pcbd.log.rpkm.df.tp$appl.exp == appl.treat.pcbd)
```

## Reshaping with Melt
* With the help of the reshape2 package and its melt() function we can stack the data frame. 
* As a result, per gene subsets of our data frame will be appended instead of having observations per gene as individual columns. 
* Also, we order the data frame alphabetically according to the gene symbol.
```{r}
bar.df<-reshape2::melt(pcbd.log.rpkm.df.tp,
                       value.name="LOG.2.RPKM")
bar.df$variable<-as.character(bar.df$variable)
colnames(bar.df)[7]<- "gene_symbol"
bar.df.ord<-bar.df[order(as.character(bar.df$gene_symbol)),]
bar.df<-bar.df.ord
rm(bar.df.ord)
head(bar.df)
```
## Modification for Barplot basing
* In order for the bars of the bar plots to be based on the x-axis, a data transformation is necessary.
```{r}
bar.df.mod<-bar.df
bar.df.mod$LOG.2.RPKM<-bar.df.mod$LOG.2.RPKM+4
head(bar.df.mod)
nrow(bar.df.mod)
```

## Definition of GOI

* Hereafter, we define genes of interest (GOI) for downstream bar plots.
* On the one hand, important genes within clusters resulting from Louvain clustering performed within the Graphia application are defined.
* On the other hand, certain genes remaining altered between allo and poly even *in vivo* are selected.

### Selected Genes of defined Clusters
* Hereafter, individual small gene sets are defined.
```{r}
cl1.goi<-c("Ctla4", "Pim1", "Kdm6b")
cl2.goi<-c("Areg", "Klrg1", "Il1rl1")
cl3.goi<-c("Icos", "Gata3", "Tnfrsf9")
cl4.goi<-c("Aurkb","Brca2","Top2a")
cl5.goi<-c("Bop1","Npm1","Rpl10a")
cl6.goi<-c("Pycard","Arhgef2","Cap1")
cl7.goi<-c("Tcf7","Lef1","Foxp1")
cl8.goi<-c("Pgk1","Eno1","Ldha")
cl9.goi<-c("Irf7","Stat2","Trim21")
avp.goi<-c("Penk","Tgm2","Lag3","Rbpj","Gpld1")
```


### List
* The GOI subsets are stored as a list for easy accessibility afterwards.
```{r}
all.goi.list<-list("cluster1"=cl1.goi,
                  "cluster2"=cl2.goi,
                  "cluster3"=cl3.goi,
                  "cluster4"=cl4.goi,
                  "cluster5"=cl5.goi,
                  "cluster6"=cl6.goi,
                  "cluster7"=cl7.goi,
                  "cluster8"=cl8.goi,
                  "cluster9"=cl9.goi,
                  "avpGenes"=avp.goi
                  )
all.goi.list
```
### Index for avp Genes
```{r}
avp.idx<-which(bar.df.mod$gene_symbol %in% all.goi.list$avpGenes)
bar.df.mod.avp<-bar.df.mod[avp.idx,]
```
### Barplots

* For avp comparisons, plots are generated individually (to adjust x scale individually).
* Lag3

```{r, fig.height=2.0, fig.width=1.5}
bar.p.mod.avp.Lag3<-ggplot(data = bar.df.mod.avp[bar.df.mod.avp$gene_symbol=="Lag3",], 
                       aes(x = group,
                           y = 2^(LOG.2.RPKM+2),
                           fill = group,
                        #   color = group,
                           shape = group))+
  coord_cartesian(clip = "off")+
  scale_y_continuous(trans = log2_trans(),
                     expand = c(0,0.1),
                     limits = c(1,16384),
                     breaks = c(1,4,16,64,256,1024,4096,16384),
                     labels = trans_format("log2", math_format(2^.x)))+
   annotation_logticks(outside = T,
                      sides = "l",
                      short = unit(0.01,"mm"), 
                      mid = unit(.5,"mm"),   
                      long = unit(1,"mm"),
                      size=.236)+
  stat_summary(fun=mean,
               geom="col",
               position = "dodge",
               width = 0.85,
               alpha=0.5)+
  geom_point(size=1,
             stroke=.236,
             colour = "black",
             position = position_jitterdodge(jitter.width=2.0, #resolution(y,zero = T)*10,
                                             dodge.width = 1.0,
                                             seed = 1234
                                             ))+
  stat_summary(fun.data = mean_se, 
               fun.args = list(mult=1), 
               geom = "errorbar", 
               color ="black", 
               linetype = "solid",
               size=0.25, 
               width=0.8, 
               position = "dodge")+
  scale_fill_manual(values = alpha(pcbd.col,0.75))+
  scale_colour_manual(values = alpha(pcbd.col,0.50))+
  scale_shape_manual(values = pcbd.shp.4)+
  theme_bw() + 
    theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 8, face = "bold", colour = "black"),
        axis.title.y = element_text(size = 8, colour = "black"),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_text(size = 6, colour = "black", angle = 90, hjust=1, vjust=0.5),
        axis.text.y = element_text(size = 6, colour = "black"),
        axis.ticks = element_line(size=.236),
        axis.line = element_line(size=.236),
        strip.background = element_blank(),
        strip.text = element_text(size = 8, face = "italic",color = "black"),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill = NA,color = "black", size=.236),
        panel.border = element_rect(colour = "black", fill=NA, size=.236),
        legend.position = "none")+
  labs(x="Treg group", 
       y = "log[2]RPKM") +
 facet_wrap(~gene_symbol, ncol = 1)
bar.p.mod.avp.Lag3
```

### Export

```{r}
pdf(file = "./FIGDIR/SupplementaryFigure3c_pcbd.avp.Lag3.barplot.expression.6+shift.pdf", width = 1.5, height = 2)
bar.p.mod.avp.Lag3
dev.off()
```

```{r}
bar.p.mod.avp.Penk<-ggplot(data = bar.df.mod.avp[bar.df.mod.avp$gene_symbol=="Penk",], 
                       aes(x = group,
                           y = 2^(LOG.2.RPKM+0),
                           fill = group,
                           shape = group))+
  coord_cartesian(clip = "off")+
  scale_y_continuous(trans = log2_trans(),
                     expand = c(0,0.1),
                     limits = c(1,4096),
                     breaks = c(1,4,16,64,256,1024,4096),
                     labels = trans_format("log2", math_format(2^.x)))+
   annotation_logticks(outside = T,
                      sides = "l",
                      short = unit(0.01,"mm"), 
                      mid = unit(.5,"mm"),   
                      long = unit(1,"mm"),
                      size=.236)+
  stat_summary(fun=mean,
               geom="col",
               position = "dodge",
               width = 0.85,
               alpha=0.5)+
  geom_point(size=1,
             stroke=.236,
             colour = "black",
             position = position_jitterdodge(jitter.width=2.0, #resolution(y,zero = T)*10,
                                             dodge.width = 1.0,
                                             seed = 1234
                                             ))+
  stat_summary(fun.data = mean_se, 
               fun.args = list(mult=1), 
               geom = "errorbar", 
               color ="black", 
               linetype = "solid",
               size=0.25, 
               width=0.8, 
               position = "dodge")+
  scale_fill_manual(values = alpha(pcbd.col,0.75))+
  scale_colour_manual(values = alpha(pcbd.col,0.50))+
  scale_shape_manual(values = pcbd.shp.4)+
  theme_bw() + 
    theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 8, face = "bold", colour = "black"),
        axis.title.y = element_text(size = 8, colour = "black"),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_text(size = 6, colour = "black", angle = 90, hjust=1, vjust=0.5),
        axis.text.y = element_text(size = 6, colour = "black"),
        axis.ticks = element_line(size=.236),
        axis.line = element_line(size=.236),
        strip.background = element_blank(),
        strip.text = element_text(size = 8, face = "italic",color = "black"),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill = NA,color = "black", size=.236),
        panel.border = element_rect(colour = "black", fill=NA, size=.236),
        legend.position = "none")+
  labs(x="Treg group", 
       y = expression("log[2]RPKM")) +
 facet_wrap(~gene_symbol, ncol = 1)

bar.p.mod.avp.Penk

```

### Export

```{r}
pdf(file = file.path(getwd(),"FIGDIR","FIGURES_MR","pcbd.avp.Penk.barplot.expression.4+shift.pdf"), width = 1.5, height = 2)
bar.p.mod.avp.Penk
dev.off()
```


```{r}
bar.p.mod.avp.Rbpj<-ggplot(data = bar.df.mod.avp[bar.df.mod.avp$gene_symbol=="Rbpj",], 
                       aes(x = group,
                           y = 2^(LOG.2.RPKM-4),
                           fill = group,
                        #   color = group,
                           shape = group))+
  coord_cartesian(clip = "off")+
  scale_y_continuous(trans = log2_trans(),
                     expand = c(0,0.1),
                     limits = c(1,24),
                     breaks = c(1,2,4,8,16),
                     labels = trans_format("log2", math_format(2^.x)))+
   annotation_logticks(outside = T,
                      sides = "l",
                      short = unit(0.01,"mm"), 
                      mid = unit(.5,"mm"),   
                      long = unit(1,"mm"),
                      size=.236)+
  stat_summary(fun=mean,
               geom="col",
               position = "dodge",
               width = 0.85,
               alpha=0.5)+
  geom_point(size=1,
             stroke=.236,
             colour = "black",
             position = position_jitterdodge(jitter.width=2.0, #resolution(y,zero = T)*10,
                                             dodge.width = 1.0,
                                             seed = 1234
                                             ))+
  stat_summary(fun.data = mean_se, 
               fun.args = list(mult=1), 
               geom = "errorbar", 
               color ="black", 
               linetype = "solid",
               size=0.25, 
               width=0.8, 
               position = "dodge")+
  scale_fill_manual(values = alpha(pcbd.col,0.75))+
  scale_colour_manual(values = alpha(pcbd.col,0.50))+
  scale_shape_manual(values = pcbd.shp.4)+
  theme_bw() + 
    theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 8, face = "bold", colour = "black"),
        axis.title.y = element_text(size = 8, colour = "black"),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_text(size = 6, colour = "black", angle = 90, hjust=1, vjust=0.5),
        axis.text.y = element_text(size = 6, colour = "black"),
        axis.ticks = element_line(size=.236),
        axis.line = element_line(size=.236),
        strip.background = element_blank(),
        strip.text = element_text(size = 8, face = "italic",color = "black"),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill = NA,color = "black", size=.236),
        panel.border = element_rect(colour = "black", fill=NA, size=.236),
        legend.position = "none")+
  labs(x="Treg group", 
       y = expression("log[2]RPKM")) +
 facet_wrap(~gene_symbol, ncol = 1)

bar.p.mod.avp.Rbpj

```

### Export

```{r}
pdf(file = file.path(getwd(),"FIGDIR","FIGURES_MR","pcbd.avp.Rbpj.barplot.expression.noshift.pdf"), width = 1.5, height = 2)
bar.p.mod.avp.Rbpj
dev.off()
```


```{r}
bar.p.mod.avp.Gpld1<-ggplot(data = bar.df.mod.avp[bar.df.mod.avp$gene_symbol=="Gpld1",], 
                       aes(x = group,
                           y = 2^(LOG.2.RPKM+2),
                           fill = group,
                        #   color = group,
                           shape = group))+
  coord_cartesian(clip = "off")+
  scale_y_continuous(trans = log2_trans(),
                     expand = c(0,0.1),
                     limits = c(1,1024),
                     breaks = c(1,4,16,64,256,1024),
                     labels = trans_format("log2", math_format(2^.x)))+
   annotation_logticks(outside = T,
                      sides = "l",
                      short = unit(0.01,"mm"), 
                      mid = unit(.5,"mm"),   
                      long = unit(1,"mm"),
                      size=.236)+
  stat_summary(fun=mean,
               geom="col",
               position = "dodge",
               width = 0.85,
               alpha=0.5)+
  geom_point(size=1,
             stroke=.236,
             colour = "black",
             position = position_jitterdodge(jitter.width=2.0, #resolution(y,zero = T)*10,
                                             dodge.width = 1.0,
                                             seed = 1234
                                             ))+
  stat_summary(fun.data = mean_se, 
               fun.args = list(mult=1), 
               geom = "errorbar", 
               color ="black", 
               linetype = "solid",
               size=0.25, 
               width=0.8, 
               position = "dodge")+
  scale_fill_manual(values = alpha(pcbd.col,0.75))+
  scale_colour_manual(values = alpha(pcbd.col,0.50))+
  scale_shape_manual(values = pcbd.shp.4)+
  theme_bw() + 
    theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 8, face = "bold", colour = "black"),
        axis.title.y = element_text(size = 8, colour = "black"),
        axis.title.x = element_text(size = 8, colour = "black"),
        axis.text.x = element_text(size = 6, colour = "black", angle = 90, hjust=1, vjust=0.5),
        axis.text.y = element_text(size = 6, colour = "black"),
        axis.ticks = element_line(size=.236),
        axis.line = element_line(size=.236),
        strip.background = element_blank(),
        strip.text = element_text(size = 8, face = "italic",color = "black"),
        plot.background = element_rect(fill="white",colour = "white"),
        panel.background = element_rect(fill = NA,color = "black", size=.236),
        panel.border = element_rect(colour = "black", fill=NA, size=.236),
        legend.position = "none")+
  labs(x="Treg group", 
       y = expression("log[2]RPKM")) +
 facet_wrap(~gene_symbol, ncol = 1)

bar.p.mod.avp.Gpld1

```

### Export

```{r}
pdf(file = file.path(getwd(),"FIGDIR","FIGURES_MR","pcbd.avp.Gpld1.barplot.expression.6+shift.pdf"), width = 1.5, height = 2)
bar.p.mod.avp.Gpld1
dev.off()
```


### average corrected and scaled CPM

```{r}
pcbd.log.cpm.cor <- pcbd.log.cpm.cor.l$pcbd.log.cpm.cor.PCR2CyNo
pcbd.log.cpmbygroup.cor <- cpmByGroup(2^pcbd.log.cpm.cor, group=group.pcbd, log=T)
pcbd.log.cpmbygroup.scaled.cor <- t(scale(t(pcbd.log.cpmbygroup.cor)))

pcbd.log.cpmbygroup.scaled.cor <- cbind.data.frame(pcbd.log.cpmbygroup.scaled.cor, GeneSymbol=strsplit2(rownames(pcbd.log.cpmbygroup.scaled.cor), split= "$", fixed = T)[,2])

```


***


